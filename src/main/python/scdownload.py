import m3u8
import requests
import tempfile
import functools
import re
import logging
import os
import sys
import json
import lxml.html
from pydub import AudioSegment
from pathlib import Path
from definitions import DATA_PATH

"""
scdownload (SoundCloud Downloader)

This file defines the main functionality to download tracks, playlists, and metadata from the SoundCloud website. 

In order to request information the app must supply a client_id which is passed into all HTTP requests. A client ID
is generated for any client that accesses a soundcloud page while authenticated. We use a static one for now that was 
extracted from a page access, but in future this could be generated by authenticating and then requesting the HTML
of a soundcloud page, or else registering for a developer client ID (which soundcloud is currently not permitting)

"""

# Limit for e.g. num comments, albums, playlists, etc. to request
request_limit = 100

logger = logging.getLogger("scdownload")

client_id = "cZQKaMjH39KNADF4y2aeFtVqNSpgoKVj"

# Request SoundCloud website pages or data from the HTTP API
def get_html(url, stream=False, fail_on_error=True):
    response = requests.get(url, stream=stream)
    if response.status_code != 200:
        logger.error("Received error reponse {0} when requesting URL {1}".format(response.status_code, url))
        if fail_on_error:
            # We exit the app on uncaught HTTP exceptions unless told not to by specifying fail_on_error=False
            sys.exit(1)
    return response

# Find the playlist name from a meta tag in the head of the HTML content of a SoundCloud page
def get_playlist_name(page_html):
    xml = lxml.html.fromstring(page_html)
    names = xml.xpath("//meta[@property='twitter:title']")
    playlist_name = names[0].attrib["content"]
    return playlist_name

# Get the metadata for a given playlist ID using the HTTP API
def get_playlist_info(playlist_id, client_id):
    playlist_info_url = "https://api.soundcloud.com/playlists/{0}?client_id={1}".format(playlist_id, client_id)
    logging.info("Requesting playlist info from URL: "+ playlist_info_url)
    playlist_info = get_html(playlist_info_url)
    playlist_data = playlist_info.json()
    logging.info("Got playlist info: "+ str(playlist_data))
    return playlist_data

# Get the metadata for a given track ID using the HTTP API
def get_track_info(track_id, client_id):
    logger.info("Track ID: " + track_id)
    track_info_url = "https://api-v2.soundcloud.com/tracks?ids={0}&client_id={1}".format(track_id, client_id)
    logger.info("Requesting track info url: " + track_info_url)
    track_info_json = get_html(track_info_url).json()
    assert len(track_info_json) == 1, "More than one track infos received for url"
    return track_info_json[0]

# Get the metadata for a given stream ID using the HTTP API
# A SoundCloud track is split into small track 'snippets' and a playlist is a collection of these snippets
# The stream info gives us the URL of each snippet and we use this to request each part individually before joining
# the parts back together to get the complete track
def get_stream_info(track_info, client_id):
    transcodings = track_info["media"]["transcodings"]
    # There are multiple formats and transcodings available in the API but we are interested in the MP3 one
    matches = list(filter(lambda x: x["format"] == {"protocol": "hls", "mime_type": "audio/mpeg"}, transcodings))
    assert len(matches) == 1, "Did not find transcoding with required format "+ transcodings
    stream_url = matches[0]["url"] + "?client_id={0}".format(client_id)
    logger.info("Requesting stream url: " + stream_url)
    stream_info = get_html(stream_url)
    return stream_info

# Download a SoundCloud track using the given track metadata
# 1. Request the playlist metadata (a playlist is a soundcloud track that has been split into many small 'snippets')
# 2. Use the m3u8 API for audio playlists to get the files in the playlist
# 2. Join these files together in order to reconstruct the track using the pydub API
def get_track(track_info, client_id):
    playlist_url = get_stream_info(track_info, client_id).json()["url"]
    logger.info("Requesting playlist url: " + playlist_url)

    m3u8_obj = m3u8.load(playlist_url)
    logger.info("Found {0} files in playlist".format(len(m3u8_obj.files)))

    files = list()
    for file_url in m3u8_obj.files:
        logger.info("Requesting playlist file url: " + file_url)
        request = get_html(file_url, stream=True)
        # We put each piece of the track into a temporary file and then join these temporary files together in order
        # to reconstruct the track
        temp = tempfile.NamedTemporaryFile(delete=False)
        received = 0
        with temp as f:
            for chunk in request.iter_content(chunk_size=1024):
                if chunk:
                    received += len(chunk)
                    f.write(chunk)
                    f.flush()
            f.seek(0)
            files.append(AudioSegment.from_file_using_temporary_files(f, 'mp3'))

    full_track = functools.reduce(lambda r, next: r + next, files)
    return full_track

# Get the artist name for a track
# This either uses the uploader name from the track metadata or else a custom function to be defined by the user
# We have the option of a custom function because the uploader name may not always correspond to the artist name
def get_artist_name(uploader_name, custom_artist_fn):
    custom_artist_name = custom_artist_fn()
    artist_name = uploader_name if custom_artist_name == "" else custom_artist_name
    return artist_name

# Get a subdirectory as a path
# E.g. given base_path = Path('/dirA/dirB/dirC') and dir = 'dirD' construct Path('/dirA/dirB/dirC/dirD') and create
# this directory if it doesn't already exist on the filesystem
def get_path(base_path, dir):
    dir_name_clean = dir.replace('.', '')
    dir_path = os.path.join(base_path, dir_name_clean)
    Path(dir_path).mkdir(exist_ok=True)
    return dir_path

# Get the path to a given track, removing special characters disallowed by the filesystem if necessary
# E.g. given artist_path = Path('/path/to/artistA') and track_name = 'myTrack 1' construct
# Path('/path/to/artistA/myTrack_1') and create this directory if it doesn't already exist on the filesystem
def get_track_path(artist_path, album_name, track_name):
    album_path = os.path.join(artist_path, album_name)
    Path(album_path).mkdir(exist_ok=True)
    # Remove special chars to make a valid file name
    track_name_clean = re.sub(r'(?u)[^-\w]', '', track_name.strip().replace(' ', '_'))
    track_path = os.path.join(album_path, track_name_clean)
    Path(track_path).mkdir(exist_ok=True)
    return track_path

# Write an audio track to the track_path with the given file_name (this uses the pydub API instead of writing the
# bytes directly to a file)
def export_track(full_track, track_path, file_name):
    file_path = os.path.join(track_path, file_name)
    logger.info("Exporting track to file: " + file_path)
    full_track.export(file_path, format="mp3")
    logger.info("Exported track to file {0}".format(file_path))

# Write the track metadata to the track_path with the given file_name using the python files API
def export_metadata(track_info, track_path, file_name):
    file_path = os.path.join(track_path, file_name)
    logger.info("Writing metadata to file: " + file_path)
    with open(file_path, "w") as metadata_file:
        metadata_file.write(json.dumps(track_info))
    logging.info("Written metadata to file: "+ file_path)

# Get the metadata for a given playlist
#
# So far the following piece of metadata are supported:
# - artist, cover art, upload date, description, length (ms), # likes, # reposts, tags, track names in the playlist
#
# Some of this already exists in the metadata from the soundcloud playlist API, otherwise it is requested via a custom
# function defined below
def get_playlist_metadata(metadata, client_id, playlist_info, playlist_path):
    results = {}
    additional_info = get_additional_playlist_info(playlist_info, client_id)
    for key in metadata:
        if key == "artist":
            results[key] = playlist_info['user']['permalink']
        elif key == "cover_art":
            if playlist_info['artwork_url']:
                export_artwork(playlist_info['artwork_url'], playlist_path)
        elif key == "date":
            results[key] = playlist_info['created_at']
        elif key == "description":
            results[key] = playlist_info['description']
        elif key == "length":
            results[key] = playlist_info['duration']
        elif key == "likes":
            results[key] = additional_info['likes_count']
        elif key == "reposts":
            results[key] = additional_info['reposts_count']
        elif key == "tags":
            results[key] = playlist_info['tag_list']
        elif key == "tracks":
            results[key] = list(map(lambda x: x['title'], playlist_info['tracks']))
        else:
            logging.error("Unknown playlist metadata key: "+ key)
    return results

# Get additional playlist metadata from the soundcloud users API (e.g. # reposts, which doesn't exist in the
# soundcloud playlist API)
def get_additional_playlist_info(playlist_info, client_id):
    additional_playlist_info_url = get_additional_playlist_info_url(playlist_info, client_id)
    logging.info("Requesting additional playlist info from URL: "+ additional_playlist_info_url)
    additional_playlist_info = get_html(additional_playlist_info_url)
    additional_playlist_data = list(filter(lambda x: x['id'] == playlist_info['id'],
                                      additional_playlist_info.json()['collection']))[0]
    logging.info("Got additional playlist info: "+ str(additional_playlist_data))
    return additional_playlist_data

# Get the playlist metadata from the soundcloud users api
# A different URL is used depending upon whether the playlist is an album or not
def get_additional_playlist_info_url(playlist_info, client_id):
    base_url = "https://api-v2.soundcloud.com/users/{0}/{1}?representation=mini&client_id={2}&limit=1000"
    if (playlist_info['kind'] == "playlist"):
        return base_url.format(playlist_info['user_id'], "playlists_without_albums", client_id)
    else:
        return base_url.format(playlist_info['user_id'], "albums", client_id)

# Get the soundcloud metadata for a given artist
# Supported metadata:
# - albums, comments, descriptions, location (country and city, full name, username, # followers, # following,
#   # likes, # reposts, user ID, status (i.e. are they pro or not), profile picture, header image, links (e.g. to
#   social media sites), playlists, spotlight (the tracks chosen by the artist to feature at the top of their page)
def get_artist_metadata(metadata, client_id, track_info, artist_path):
    user_id = track_info['user']['id']
    user_info = get_user_metadata(user_id, client_id)
    results = {}
    for key in metadata:
        if key == "albums":
            results[key] = get_user_albums_metdata(user_id, client_id)
        elif key == "comments":
            results[key] = get_user_comments_metadata(user_id, client_id)
        elif key == "description":
            results[key] = user_info['description']
        elif key == "location":
            results[key] = {
                "country": user_info['country'],
                "city": user_info['city']
            }
        elif key == "name":
            results[key] = user_info['full_name']
        elif key == "username":
            results[key] = user_info['username']
        elif key == "followers":
            results[key] = user_info['followers_count']
        elif key == "following":
            results[key] = user_info['followings_count']
        elif key == "likes":
            results[key] = user_info['likes_count']
        elif key == "reposts":
            results[key] = user_info['reposts_count']
        elif key == "user_id":
            results[key] = user_id
        elif key == "status":
            # A user is considered 'pro' if they have a pro creator subscription to soundcloud
            results['pro'] = \
                user_info['subscriptions'] and user_info['subscriptions'][0]['product']['id'] == "creator-pro-unlimited"
        elif key == "profile_picture":
            export_user_avatar(user_info['avatar_url'], artist_path)
        elif key == "header":
            export_header_image(user_info, artist_path)
        elif key == "links":
            results[key] = get_user_links(user_id, client_id)
        elif key == "playlists":
            results[key] = get_user_playlists(user_id, client_id)
        elif key == "spotlight":
            results[key] = get_user_spotlight(user_id, client_id)
        else:
            logger.error("Unknown artist metadata key: " + key)
    return results

# Get the tracks in the spotlight for a given user ID
# The tracks in spotlight feature at the top of an artist's page on SoundCloud
def get_user_spotlight(user_id, client_id):
    spotlight_url = "https://api-v2.soundcloud.com/users/{0}/spotlight?" \
                    "client_id={1}&limit={2}".format(user_id, client_id, request_limit)
    logging.info("Requesting user spotlight from URL: "+ spotlight_url)
    spotlight_info = get_html(spotlight_url)
    spotlight_data = list(map(lambda x: x['title'], spotlight_info.json()['collection']))
    logging.info("Got user spotlight data: "+ str(spotlight_data))
    return spotlight_data

# Get the names of playlists created by a given user ID
def get_user_playlists(user_id, client_id):
    playlists_url = "https://api-v2.soundcloud.com/users/{0}/playlists_without_albums?representation=mini?" \
                    "&client_id={1}&limit={2}".format(user_id, client_id, request_limit)
    logger.info("Requesting playlists metadata from URL: " + playlists_url)
    playlists_info = get_html(playlists_url)
    playlists_data = list(map(lambda x: x['title'], playlists_info.json()['collection']))
    logger.info("Got playlist names: " + str(playlists_data))
    return playlists_data

# Get the links for a given user ID
# These usually include e.g. links to an artist's social media profiles
def get_user_links(user_id, client_id):
    user_links_url = "https://api-v2.soundcloud.com/users/soundcloud:users:{0}/web-profiles?" \
                     "client_id={1}".format(user_id, client_id)
    logger.info("Requesting user links from URL: "+ user_links_url)
    user_links_data = get_html(user_links_url).json()
    logger.info("Got user links: "+ str(user_links_data))
    return user_links_data

# Get the URL for the header image of an artist's page
# It is difficult to determine this when looking at the HTML of the artist's page without javascript enabled, but
# luckily the URL is stored in a property at the end of the page which has an attribute on it called 'visual_url'
# We extract this using a regular express which is looking for a string of the form visual_url="my_visual_url"
# and extracts a string like my_visual_url from this
def get_header_url(page_html):
    header_url = re.search(r'visual_url":"(.+?)"', page_html).group(1)
    return header_url

# Download and export the header image for a given soundcloud artist (if one exists) to a file named header.jpg
# in the artist directory, overwriting the old one if it exists
def export_header_image(user_info, artist_path):
    user_url = user_info['permalink_url']
    logger.info("Requesting artist html page: "+ user_url)
    user_info = get_html(user_url)
    logger.info("Got artist html page")
    header_url = get_header_url(user_info.text)
    logger.info("Requesting header image from URL: "+ header_url)
    header_data = get_html(header_url)
    export_image(header_data.content, artist_path, "header.jpg")

# Download and export the profile picure for a given soundcloud artist and write it to a file names avatar.jpg
# in the artist directory, overwriting the old one if it exists.
# Other formats and sizes are available but at the moment we use the smallest size (to make downloads quicker) and
# jpeg format since this is very commonly supported
def export_user_avatar(avatar_url, artist_path):
    logging.info("Requesting user avatar image from url: " + avatar_url)
    avatar_image_info = get_html(avatar_url)
    export_image(avatar_image_info.content, artist_path, "avatar.jpg")
    logging.info("Written user avatar image")

# Get the metadata (in json format) for a soundcloud artist given the artist's user_id
def get_user_metadata(user_id, client_id):
    user_url = "https://api.soundcloud.com/users/{0}?client_id={1}".format(user_id, client_id)
    logger.info("Requesting user metadata from URL: "+ user_url)
    user_info = get_html(user_url)
    user_data = user_info.json()
    logger.info("Got user metadata: "+ str(user_data))
    return user_data

# Get the names of albums that an artist has uploaded given the artist's user_id
def get_user_albums_metdata(user_id, client_id):
    albums_url = "https://api-v2.soundcloud.com/users/{0}/albums?" \
                 "client_id={1}&limit={2}".format(user_id, client_id, request_limit)
    logger.info("Requesting albums metadata from URL: "+ albums_url)
    albums_info = get_html(albums_url)
    albums_data = list(map(lambda x: x['title'], albums_info.json()['collection']))
    logger.info("Got album names: "+ str(albums_data))
    return albums_data

# Get the metadata of comments left by a particular artist given the artist's user_id
# Currently supported information:
# - date of comment, comment content, timestamp of the comment (i.e. the point in ms at which the comment was left on
#   the track), the track name which the comment was left on, the url of the track which the comment was left on
def get_user_comments_metadata(user_id, client_id):
    comments_url = "https://api-v2.soundcloud.com/users/{0}/comments?" \
                   "client_id={1}&limit={2}".format(user_id, client_id, request_limit)
    logger.info("Requesting comments metadata from URL: "+ comments_url)
    comments_info = get_html(comments_url)
    comments_data = list(map(lambda x: {
        "date": x["created_at"],
        "comment": x["body"],
        "timestamp": x["timestamp"],
        "track_name": x["track"]["title"],
        "track_url": x["track"]["permalink_url"]
    }, comments_info.json()['collection']))
    logger.info("Got comments: "+ str(comments_data))
    return comments_data


# Get the metadata for a particular track
# Currently supported metadata:
# - playlists which the track is in, albums which the track is in, background image of the track (if it exists),
#   the track's artist, cover art for the track, date the track was uploaded, descriptions, # likes, # listens,
#   # reposts, tags, names of related tracks, status (i.e. GO+ or not), comments left on the track
def get_track_metadata(metadata, client_id, track_id, track_info, track_path):
    results = {}
    for key in metadata:
        if key == "playlists":
            results[key] = get_track_playlists_metadata(track_id, client_id)
        elif key == "albums":
            results[key] = get_track_albums_metadata(track_id, client_id)
        elif key == "background":
            export_background_image(track_id, track_path)
        elif key == "artist":
            results[key] = track_info['user']['username']
        elif key == "cover_art":
            export_artwork(track_info["artwork_url"], track_path)
        elif key == "date":
            results[key] = track_info['created_at']
        elif key == "description":
            results[key] = track_info['description']
        elif key == "likes":
            results[key] = track_info['likes_count']
        elif key == "listens":
            results[key] = track_info['playback_count']
        elif key == "reposts":
            results[key] = track_info['reposts_count']
        elif key == "tags":
            results[key] = track_info['tag_list']
        elif key == "related_tracks":
            results[key] = get_related_metadata(track_id, client_id)
        elif key == "status":
            results[key] = get_status(track_info)
        elif key == "comments":
            results[key] = get_comments(track_id, client_id)
        else:
            logger.error("Unknown track metadata key: "+ key)
    return results

# Get the comments left on a track for a given track_id
# Information supported includes:
# - date when the comment was left, comment content, timestamp (in ms) where the comment was left on the track,
#   full name of the user who left the comment
def get_comments(track_id, client_id):
    comments_url = "https://api-v2.soundcloud.com/tracks/{0}/comments?threaded=1&filter_replies=0&" \
                   "client_id={1}&limit={2}".format(track_id, client_id, request_limit)
    logging.info("Requesting comments metadata from url: "+ comments_url)
    comments_info = get_html(comments_url)
    comments_data = list(map(lambda x: {
        "date": x["created_at"],
        "comment": x["body"],
        "timestamp": x["timestamp"],
        "name": x["user"]["full_name"]
    }, comments_info.json()["collection"]))
    logging.info("Got comments data: "+ str(comments_data))
    return comments_data

# Get the status of a track, i.e. is it marked GO+ or not
# This corresponds to whether the monetization model is "SUB_HIGH_TIER" or not
def get_status(track_info):
    if track_info['monetization_model'] == "SUB_HIGH_TIER":
        return "GO+"
    else:
        return "free"

# Export the artwork for a track to a file (default name artwork.jpg)
def export_artwork(artwork_url, path, filename="artwork"):
    logger.info("Requesting artwork url: " + artwork_url)
    artwork_info = get_html(artwork_url)
    artwork_name, artwork_ext = os.path.splitext(artwork_url)
    artwork_file_name = filename + artwork_ext
    export_image(artwork_info.content, path, artwork_file_name)
    logging.info("Written artwork to file: " + artwork_file_name)

# Export the background image of a track (if one exists) to a file (default name background.jpg)
def export_background_image(track_id, track_path, filename="background.jpg"):
    background_image_url = "https://va.sndcdn.com/bg/soundcloud:tracks:{0}/soundcloud-tracks-{0}.jpg".format(track_id)
    logging.info("Requesting background image from url: "+ background_image_url)
    background_image_info = get_html(background_image_url, fail_on_error=False)
    if background_image_info.status_code != 200:
        logging.info("Background image not found for track")
    else:
        export_image(background_image_info.content, track_path, filename)
        logging.info("Written background image")

# Get the metadata of playlists that a track is included in given the track_id
def get_track_playlists_metadata(track_id, client_id):
    playlists_url = "https://api-v2.soundcloud.com/tracks/{0}/playlists_without_albums?representation=mini&" \
                    "client_id={1}&limit={2}".format(track_id, client_id, request_limit)
    logging.info("Requesting playlists metadata from url: "+ playlists_url)
    playlists_info = get_html(playlists_url)
    playlist_names = list(map(lambda x: x["title"], playlists_info.json()["collection"]))
    logging.info("Got playlist names: "+ str(playlist_names))
    return playlist_names

# Get the metadata of albums that a track is included in given the track_id
def get_track_albums_metadata(track_id, client_id):
    albums_url = "https://api-v2.soundcloud.com/tracks/{0}/albums?representation=mini&" \
                    "client_id={1}&limit={2}".format(track_id, client_id, request_limit)
    logging.info("Requesting albums metadata from url: "+ albums_url)
    albums_info = get_html(albums_url)
    album_names = list(map(lambda x: x["title"], albums_info.json()["collection"]))
    logging.info("Got album names: "+ str(album_names))
    return album_names

# Get the names of tracks related to the one specified by the given track_id
def get_related_metadata(track_id, client_id):
    related_url = "https://api-v2.soundcloud.com/tracks/{0}/related?" \
                  "client_id={1}&limit={2}".format(track_id, client_id, request_limit)
    logging.info("Requesting related tracks metadata from url: "+ related_url)
    related_info = get_html(related_url)
    related_names = list(map(lambda x: x["title"], related_info.json()["collection"]))
    logging.info("Got related track names: "+ str(related_names))
    return related_names

# Export an image related to the track (e.g. artwork, background image, etc.) to the track_path with the given file_name
def export_image(artwork, track_path, file_name):
    image_file_path = os.path.join(track_path, file_name)
    logger.info("Writing image to file: " + image_file_path)
    with open(image_file_path, "wb") as image_file:
        image_file.write(artwork)

# Archive the track, metadata, images, etc to a given path
def archive_track(track_id, client_id, custom_artist_fn, track_metadata, artist_metadata, album_name="Singles", base_path=DATA_PATH):
    # First get the track metadata which tells us the playlist URL of the track (used to download it) and other metadata
    track_info = get_track_info(track_id, client_id)

    track_name = track_info["title"]
    logger.info("Track name: " + track_name)

    # Request the track snippets from the playlist metadata and join them back together into a complete MP3 file
    full_track = get_track(track_info, client_id)

    uploader_name = track_info["user"]["username"]
    logger.info(
        "Track uploader was {0}. Press enter to continue or provide an alternative artist name: ".format(uploader_name))

    artist_name = get_artist_name(uploader_name, custom_artist_fn)
    logger.info("Chosen artist name is: " + artist_name)

    artist_path = get_path(base_path, artist_name)

    track_path = get_track_path(artist_path, album_name, track_name)
    logger.info("Track path is: " + track_path)

    # Write the reconstructed MP3 file to a file named 'track.mp3' in the track directory
    export_track(full_track, track_path, "track.mp3")

    if track_metadata == []:
        # Export the default track metadata if no custom metadata keys are specified
        export_metadata(track_info, track_path, "meta.json")
    else:
        # Export additional track metadata specified by the metadata keys
        track_metadata1 = get_track_metadata(track_metadata, client_id, track_id, track_info, track_path)
        export_metadata(track_metadata1, track_path, "meta.json")

    if artist_metadata != []:
        # Export additional artist metatdata specified by the metadata keys
        artist_metadata1 = get_artist_metadata(artist_metadata, client_id, track_info, artist_path)
        export_metadata(artist_metadata1, artist_path, "meta.json")

# Main entry point to the API
# Download a track (or set of tracks in playlist) given a soundcloud track (or playlist) URL
# Additionally download custom metadata defined by the given metadata keys, or else the default metadata
# Write the files to a directory substructure
# Throw if the given URL is not a valid soundcloud track (or playlist) URL
def download(url, custom_artist_fn, track_metadata=[], artist_metadata=[], playlist_metadata=[]):
    logger.info("Requesting SoundCloud url: " + url)
    response = get_html(url)

    # We determine the track (or playlist) ID by searching for a meta tag in the header of the page which matches
    # strings of the form: soundcloud://sounds:12345 where 12345 is the track (or playlist) ID
    track_search = re.search(r'soundcloud://sounds:(.+?)"', response.text)
    playlist_search = re.search(r'soundcloud://playlists:(.+?)"', response.text)

    if track_search != None:
        track_id = track_search.group(1)
        logger.info("Found track ID {0} on page. Dowloading track...".format(track_id))
        archive_track(track_id, client_id, custom_artist_fn, track_metadata, artist_metadata)
        return 0
    elif playlist_search != None:
        playlist_id = playlist_search.group(1)
        logger.info("Found playlist ID {0} on page. Downloading playlist...".format(playlist_id))
        playlist_name = get_playlist_name(response.content)
        logger.info("Playlist name: " + playlist_name)
        playlist_info = get_playlist_info(playlist_id, client_id)

        playlist_author_path = get_path(DATA_PATH, playlist_info['user']['permalink'])
        playlist_path = get_path(playlist_author_path, playlist_name)

        # For playlists we request each individual track in the playlist (derived from the playlist metadata) and put
        # them into the corresponding playlist directory structure
        for track_info in playlist_info['tracks']:
            archive_track(str(track_info["id"]), client_id, custom_artist_fn, track_metadata, artist_metadata,
                          album_name=playlist_name, base_path=playlist_path)

        playlist_metadata1 = get_playlist_metadata(playlist_metadata, client_id, playlist_info, playlist_path)
        export_metadata(playlist_metadata1, playlist_path, "meta.json")

        return 0
    else:
        logger.error("No valid track or playlist ID found on page. Is this a valid SoundCloud link?")
        return -1

# Currently we access the API via the python GUI but this method is retained in order to download the tracks via a
# command line interface. This is also useful for testing without the GUI enabled
def run_cmdline():
    # url = "https://soundcloud.com/yung-bruh-3/gemstone-bullets-poppin-out-the-tech"
    logger.info("Enter the SoundCloud URL of the track/playlist to download: ")
    soundcloud_url = input()
    result = download(soundcloud_url, input)
    if result < 0:
        sys.exit(result)